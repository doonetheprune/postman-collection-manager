import axios from 'axios';
import { readFileSync } from 'fs';
import { validate as uuidValidate } from 'uuid';
import yargs from 'yargs';
import { hideBin } from 'yargs/helpers';

const argv = yargs(hideBin(process.argv))
    .option('apiKey', {
        alias: 'k',
        type: 'string',
        description: 'The API key for the Postman API',
        demandOption: true
    })
    .option('collection', {
        alias: 'm',
        type: 'string',
        description: 'The name of the collection to merge into',
        demandOption: true
    })
    .option('workspace', {
        alias: 'w',
        type: 'string',
        description: 'The name or ID of the workspace',
        demandOption: true
    })
    .option('folderName', {
        alias: 'f',
        type: 'string',
        description: 'Name of the folder to be added to the collection',
        demandOption: true
    })
    .option('collectionJsonFile', {
        alias: 'c',
        type: 'string',
        description: 'The file path to the Postman collection JSON',
        demandOption: true
    })
    .option('createCollectionIfMissing', {
        alias: 'create',
        type: 'boolean',
        description: 'Create the collection if it does not exist',
        default: false
    })
    .parseSync();
let currentPostmanCollection: any = JSON.parse(
    readFileSync(argv.collectionJsonFile).toString('utf-8')
);

const newFolder = {
    name: argv.folderName,
    description: "Generated By Shaun Betts",
    item: currentPostmanCollection.item,
};

const instance = axios.create({
    baseURL: 'https://api.getpostman.com/',
    headers: {
        'Content-Type': 'application/json',
        'X-API-Key': argv.apiKey || '',
    },
});

const getWorkspaceId = async () => {
    const workspace = argv.workspace;

    if (workspace === null) {
        return null;
    } else if (uuidValidate(argv.workspace as string)) {
        console.log('Workspace Name Is A UUID So It Is Being Used As the `workspaceId`');
        return argv.workspace;
    }

    try {
        const res = await instance.get('/workspaces');
        const workspace: any = res?.data?.workspaces.filter((currentWorkspace: any) => {
            return currentWorkspace.name === argv.workspace;
        })[0];

        if (!workspace) {
            console.error(`Workspace '${name}' not found`);
            process.exit();
        }
        return workspace.id;
    } catch (err: any) {
        console.log(err);
        console.error('Error Fetching Workspaces Using Api Key', argv.apiKey);
        process.exit();
    }
};

const getCollectionId = async (workspaceId: string | null, collectionName: string | null = null) => {
    try {
        const res = await instance.get('/collections', { params: { workspace: workspaceId } });
        const collection = res?.data?.collections.find((currentCollection: any) => currentCollection.name === collectionName);

        if (!collection && argv.createCollectionIfMissing) {
            console.log(`[2.5/5] Collection '${collectionName}' not found, creating new one.`);
            const newCollectionRes = await instance.post(`/collections?workspace=${workspaceId}`, {
                collection: {
                    info: {
                        name: collectionName,
                        schema: 'https://schema.getpostman.com/collection/v1'
                    },
                    item: []
                }
            });
            return newCollectionRes.data.collection.id;
        } else if (!collection) {
            console.error(`Collection '${collectionName}' not found and not creating new one.`);
            process.exit();
        }
        return collection.id;
    } catch (err: any) {
        console.error('Error Fetching or Creating Collections Using Api Key', argv.apiKey);
        console.error(err.request);
        process.exit();
    }
};

const loadFullCollection = async (collectionId: string) => {
    try {
        const res = await instance.get('/collections/' + collectionId);
        return res.data.collection;
    } catch (err: any) {
        console.log(err);
        console.error('Error Fetching Full Collection Using Collection ID', collectionId);
        process.exit();
    }
};

const mergeCollection = (collection: any) => {
    collection.item = collection.item.filter((item: any) => item.name !== argv.folderName);
    collection.item.push(newFolder);
    return collection;
};

const updateCollection = async (collectionId: string, collection: any) => {
    try {
        await instance.put('/collections/' + collectionId, { collection });
    } catch (err: any) {
        console.log(err);
        console.log(err?.response?.data);
        console.error('Error Updating Collection Using Collection ID', collectionId);
        process.exit();
    }
};

(async () => {
    console.log('[1/5] Finding Workspace -', argv.workspace);
    const workspaceId: string = await getWorkspaceId();

    console.log('[2/5] Finding Collection - ', argv.collection);
    const collectionId: string = await getCollectionId(workspaceId, argv.collection);

    console.log('[3/5] Loading The Full Collection');
    let fullCollection: any = await loadFullCollection(collectionId);

    console.log('[4/5]  Merging Collections');
    fullCollection = mergeCollection(fullCollection);

    console.log('[5/5]  Updating The Collection - ', collectionId);
    await updateCollection(collectionId, fullCollection);

    console.log('All Done');
    process.exit();
})();
